# Snapshot schema_nutrition.graphql @ v0.1.0
# Usato in CI per diff breaking

"Piano nutrizionale corrente dell'utente"
type NutritionPlan {
  targetCalories: Int!
  proteinTarget: Int!
  carbsTarget: Int!
  fatTarget: Int!
  strategy: GoalStrategy!
  updatedAt: DateTime!
}

"Valori nutrizionali standard (default 100g)"
type Nutrients {
  calories: Int!
  protein: Float!
  carbs: Float!
  fat: Float!
  fiber: Float
  sugar: Float
  sodium: Float
}

"Porzione suggerita per ridurre attrito nel logging"
type Portion {
  label: String!
  grams: Float!
}

"Alimento normalizzato nel database interno"
type FoodItem implements Node @cacheControl(maxAge: 3600) {
  id: ID!
  name: String!
  brand: String
  category: String
  nutrients: Nutrients!
  portionSuggestions: [Portion!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"Dettaglio pasto loggato"
type MealEntry implements Node {
  id: ID!
  mealType: MealType!
  food: FoodItem!
  quantity: Float!
  unit: String!
  nutrients: Nutrients!
  createdAt: DateTime!
}

"Riepilogo nutrizionale giornaliero (materializzato o calcolato)"
type DailyNutritionSummary {
  date: Date!
  total: Nutrients!
  adherenceCalories: Float!
  remainingCalories: Int!
  macroAdherence: Float!
  mealCount: Int!
}

"Risultato inference AI foto pasto"
type AIInferenceResult implements Node {
  id: ID!
  rawLabel: String!
  confidence: Float!
  normalizedFood: FoodItem
  status: InferenceStatus!
  createdAt: DateTime!
  items: [AIInferenceItem!]
  autoFilled: Boolean
}

"Item candidato riconosciuto dall'AI con grounding nutrizionale opzionale"
type AIInferenceItem {
  id: ID
  label: String!
  grams: Float
  originalGrams: Float
  portionAdjusted: Boolean!
  uncertainty: UncertaintyBand
  confidence: Float!
  matchFoodItemId: ID
  source: InferenceSource!
}

type UncertaintyBand { low: Float!, high: Float! }

enum InferenceSource { BARCODE OPEN_FOOD_FACTS INTERNAL_DB GENERIC }

type PageInfo { hasNextPage: Boolean!, hasPreviousPage: Boolean!, startCursor: String, endCursor: String }

type FoodItemEdge { cursor: String!, node: FoodItem! }

type FoodItemConnection { edges: [FoodItemEdge!]!, pageInfo: PageInfo!, totalCount: Int }

type MealEntryEdge { cursor: String!, node: MealEntry! }

type MealEntryConnection { edges: [MealEntryEdge!]!, pageInfo: PageInfo! }

input LogMealInput {
  mealType: MealType!
  foodId: ID!
  quantity: Float!
  unit: String!
}

input UpdateNutritionPlanInput {
  strategy: GoalStrategy
  targetCalories: Int
  proteinTarget: Int
  carbsTarget: Int
  fatTarget: Int
}

input FoodSearchFilter {
  category: String
  minProtein: Float
  maxCalories: Int
}

enum MealType { BREAKFAST LUNCH DINNER SNACK }

enum GoalStrategy { CUT MAINTAIN BULK }

enum InferenceStatus { PENDING MATCHED REJECTED CONFIRMED }

extend type Query {
  myNutritionPlan: NutritionPlan
  dailyNutrition(date: Date!): DailyNutritionSummary
  nutritionSummaryRange(start: Date!, end: Date!): [DailyNutritionSummary!]!
  meals(date: Date!): [MealEntry!]!
  mealsConnection(dateFrom: Date!, dateTo: Date!, first: Int, after: String): MealEntryConnection!
  searchFoodsConnection(query: String!, first: Int, after: String, filter: FoodSearchFilter): FoodItemConnection!
  aiInference(id: ID!): AIInferenceResult
}

extend type Mutation {
  logMeal(input: LogMealInput!): MealEntry!
  updateNutritionPlan(input: UpdateNutritionPlanInput!): NutritionPlan!
  analyzeMealPhoto(uploadId: ID!): AIInferenceResult!
  confirmInference(id: ID!, selections: [InferenceSelectionInput!]!): [MealEntry!]!
}

input InferenceSelectionInput {
  inferenceItemId: ID
  foodId: ID!
  quantity: Float!
  unit: String!
}

"Delta giornaliero pushato via subscription per aggiornare ring senza refetch"
type DailyNutritionDelta {
  date: Date!
  addedCalories: Int!
  addedProteinG: Float!
  addedCarbsG: Float!
  addedFatG: Float!
  mealEntryId: ID
  source: NutritionDeltaSource!
}

enum NutritionDeltaSource { MANUAL AI EDIT DELETE }

extend type Subscription {
  dailyNutritionUpdated(date: Date!): DailyNutritionDelta!
}
