# Copilot Instructions - Extended Version

## 1. ARCHITETTURA PROGETTO
* Backend: backend/ → **focus principale**.
* Altre cartelle: mobile/, web/ → **non modificare salvo richiesta esplicita**.
* Tutte le operazioni di default devono riguardare **solo il backend**.

## 2. GESTIONE OPERAZIONI
* Usa **sempre** ./make.sh per:
  * Test
  * Versionamento
  * Build & deployment
  * Avvio Docker
* Prima di eseguire qualsiasi operazione, verifica i target disponibili:
```bash
cat ./make.sh
```

## 3. AMBIENTE PYTHON
* Attiva **sempre** il virtual environment backend/.venv:
```bash
source backend/.venv/bin/activate
```
* Usa **solo** il package manager uv per tutte le operazioni Python:
```bash
uv install
uv run
uv add <package>
```
* **Non usare** pip, poetry o altri strumenti.

## 4. TERMINALI
* Limite massimo: **3 terminali**
  1. BUILD → sviluppo e build
  2. TEST → esecuzione test
  3. GIT → operazioni git
* **Non aprire terminali aggiuntivi.**

## 5. NAVIGAZIONE E ORIENTAMENTO
* Esegui sempre pwd prima di qualsiasi comando.
* Verifica la directory corrente e usa cd se necessario.

## 6. GESTIONE GIT
* Prima di ogni commit:
  1. Esegui git status
  2. Controlla staging e working directory
  3. Assicurati che non ci siano file indesiderati
* Solo dopo questi controlli procedi con il commit.

## 7. SEQUENZA OPERATIVA STANDARD
1. Orientamento: pwd
2. Ambiente: attiva virtual env
3. Status check: git status
4. Operazione: ./make.sh [target]
5. Verifica: controlla risultati

## 8. COMANDI PRINCIPALI
```bash
# Orientamento
pwd

# Ambiente Python
source backend/.venv/bin/activate

# Operazioni principali
./make.sh [target]

# Package management
uv [comando]

# Controllo versioning
git status
```

## 9. FOCUS E PRIORITÀ
**Concentrati su:**
* Backend development
* Uso di make.sh per tutte le operazioni
* Gestione corretta del virtual environment
* Controlli git accurati

**Evita:**
* Apertura terminali extra
* Comandi Python senza virtual env
* Operazioni dirette senza make.sh
* Lavoro su mobile/web non richiesto

## 10. DOCUMENTAZIONE
* La documentazione principale parte dal file README.md nella root.
* Tutta la documentazione aggiuntiva si trova nella cartella docs/.
* Leggere **tutta la documentazione** in caso di dubbi o incertezze.

---

# 🚨 NUOVE SEZIONI - ARCHITETTURA E BEST PRACTICES

## 11. ARCHITETTURA LAYERED - STRUTTURA OBBLIGATORIA

### 11.1 Struttura Directory Target
```
backend/
├── app/
│   ├── api/              # Layer API/Presentazione
│   │   ├── graphql/      # Schema GraphQL e resolver Strawberry
│   │   ├── rest/         # Endpoint REST (se necessari)
│   │   └── middleware/   # Middleware FastAPI
│   ├── domain/           # Layer Business Logic (PURO)
│   │   ├── models/       # Domain models (dataclass, NOT ORM)
│   │   ├── services/     # Business logic services
│   │   └── exceptions/   # Domain-specific exceptions
│   ├── infrastructure/   # Layer Infrastruttura
│   │   ├── database/     # Repository, ORM, queries
│   │   ├── external/     # API esterne, HTTP clients
│   │   ├── cache/        # Redis, in-memory cache
│   │   └── config/       # Configurazioni
│   └── core/             # Shared/Common
│       ├── dependencies/ # Dependency Injection
│       ├── utils/        # Utilities pure
│       └── types/        # Type definitions comuni
```

### 11.2 Principi di Separazione
* **API layer** → Solo input/output, validazione request, chiamate a services
* **Domain layer** → Business logic PURA, no I/O, no HTTP, no DB
* **Infrastructure layer** → I/O, database, API esterne, filesystem

**REGOLA D'ORO**: Domain NON deve mai importare da API o Infrastructure

## 12. ANTIPATTERN DA EVITARE 🚫

### 12.1 Async/Await
❌ **EVITARE:**
```python
# Blocking I/O in async function
async def get_user(user_id: int):
    time.sleep(1)  # MALE! Blocca event loop
    return db.query(User).filter_by(id=user_id).first()  # Sync in async
```

✅ **CORRETTO:**
```python
async def get_user(user_id: int):
    await asyncio.sleep(1)  # Non-blocking
    return await db_async.execute(select(User).where(User.id == user_id))
```

### 12.2 Memory Leaks
❌ **EVITARE:**
```python
# Global state mutabile
CACHE = {}  # Cresce infinitamente

async def store_data(key: str, value: Any):
    CACHE[key] = value  # Memory leak!
```

✅ **CORRETTO:**
```python
from functools import lru_cache
from cachetools import TTLCache

# Cache con dimensione e TTL
cache: TTLCache = TTLCache(maxsize=1000, ttl=3600)

async def store_data(key: str, value: Any):
    cache[key] = value  # Auto-eviction
```

### 12.3 Resource Management
❌ **EVITARE:**
```python
# Client HTTP non chiuso
async def fetch_data():
    client = httpx.AsyncClient()
    response = await client.get("https://api.example.com")
    return response.json()  # client non chiuso!
```

✅ **CORRETTO:**
```python
async def fetch_data():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com")
        return response.json()  # Auto-cleanup
```

### 12.4 Codice Procedurale
❌ **EVITARE:**
```python
# Tutto in un file, logica duplicata
async def create_meal(data: dict):
    # Validazione inline
    if not data.get("name"):
        raise ValueError("Name required")
    # Business logic inline
    calories = sum(i["calories"] for i in data["ingredients"])
    # Persistenza inline
    db.execute("INSERT INTO meals ...")
    # Notifiche inline
    await send_email(...)
```

✅ **CORRETTO:**
```python
# Domain service
class MealService:
    def __init__(self, repo: MealRepository, notifier: Notifier):
        self._repo = repo
        self._notifier = notifier
    
    async def create_meal(self, command: CreateMealCommand) -> Meal:
        meal = Meal.create(command)  # Factory domain
        meal.calculate_nutrition()   # Business logic
        await self._repo.save(meal)
        await self._notifier.notify_meal_created(meal)
        return meal
```

## 13. PATTERN E LIBRERIE DA PREDILIGERE ✅

### 13.1 Dependency Injection
**Usa SEMPRE dependency injection di FastAPI:**
```python
from fastapi import Depends
from typing import Annotated

# Dependencies file
def get_db_session() -> AsyncSession:
    async with async_session_maker() as session:
        yield session

def get_meal_service(
    db: Annotated[AsyncSession, Depends(get_db_session)]
) -> MealService:
    repo = MealRepository(db)
    return MealService(repo)

# In resolver Strawberry
@strawberry.type
class Query:
    @strawberry.field
    async def meal(
        self,
        info: Info,
        meal_id: int,
        service: Annotated[MealService, Depends(get_meal_service)]
    ) -> Meal:
        return await service.get_meal(meal_id)
```

### 13.2 Dataclasses & Type Safety
**Usa dataclasses e pydantic per domain models:**
```python
from dataclasses import dataclass, field
from typing import NewType

UserId = NewType("UserId", int)
MealId = NewType("MealId", int)

@dataclass(frozen=True)  # Immutabile
class Meal:
    id: MealId
    user_id: UserId
    name: str
    calories: int
    created_at: datetime = field(default_factory=datetime.utcnow)
    
    def __post_init__(self):
        if self.calories < 0:
            raise ValueError("Calories cannot be negative")
```

### 13.3 Repository Pattern
**SEMPRE usa repository per accesso dati:**
```python
from abc import ABC, abstractmethod
from typing import Protocol

class MealRepository(Protocol):
    async def get_by_id(self, meal_id: MealId) -> Meal | None: ...
    async def save(self, meal: Meal) -> None: ...
    async def find_by_user(self, user_id: UserId) -> list[Meal]: ...

# Implementation
class PostgresMealRepository:
    def __init__(self, session: AsyncSession):
        self._session = session
    
    async def get_by_id(self, meal_id: MealId) -> Meal | None:
        result = await self._session.execute(
            select(MealModel).where(MealModel.id == meal_id)
        )
        model = result.scalar_one_or_none()
        return self._to_domain(model) if model else None
```

### 13.4 Result Type invece di Eccezioni
**Per flow control, usa Result type:**
```python
from typing import Generic, TypeVar
from dataclasses import dataclass

T = TypeVar("T")
E = TypeVar("E")

@dataclass(frozen=True)
class Ok(Generic[T]):
    value: T

@dataclass(frozen=True)
class Err(Generic[E]):
    error: E

Result = Ok[T] | Err[E]

# Uso
async def create_meal(command: CreateMealCommand) -> Result[Meal, str]:
    if not command.name:
        return Err("Name is required")
    
    meal = Meal.create(command)
    await repo.save(meal)
    return Ok(meal)
```

### 13.5 Context Manager per Resources
**SEMPRE usa context manager per cleanup:**
```python
from contextlib import asynccontextmanager
from typing import AsyncIterator

@asynccontextmanager
async def get_api_client() -> AsyncIterator[httpx.AsyncClient]:
    client = httpx.AsyncClient(timeout=30.0)
    try:
        yield client
    finally:
        await client.aclose()

# Uso
async def fetch_nutrition_data():
    async with get_api_client() as client:
        response = await client.get("...")
        return response.json()
```

## 14. GESTIONE MEMORIA E PERFORMANCE 🚀

### 14.1 Limitazioni Concorrenza
```python
import asyncio
from asyncio import Semaphore

# Limita chiamate concorrenti
semaphore = Semaphore(10)

async def process_meal(meal_id: int):
    async with semaphore:
        # Max 10 concurrent
        await heavy_processing(meal_id)
```

### 14.2 Streaming per Dati Grandi
```python
# NO - carica tutto in memoria
async def get_all_meals():
    return await db.execute(select(Meal)).all()

# YES - stream results
async def stream_meals() -> AsyncIterator[Meal]:
    async for row in db.stream(select(Meal)):
        yield row
```

### 14.3 Connection Pooling
```python
from sqlalchemy.ext.asyncio import create_async_engine

# Pool configurato correttamente
engine = create_async_engine(
    DATABASE_URL,
    pool_size=10,          # Connessioni persistenti
    max_overflow=20,       # Extra temporanee
    pool_pre_ping=True,    # Verifica health
    pool_recycle=3600,     # Ricicla dopo 1h
)
```

## 15. STANDARD CODICE E QUALITY 📐

### 15.1 Type Hints OBBLIGATORI
```python
# SEMPRE annota tipi
async def calculate_nutrition(
    meals: list[Meal],
    user_weight: float,
) -> NutritionSummary:
    ...

# NO generics nudi
def process(data): ...  # ❌

# YES
def process(data: list[dict[str, Any]]) -> ProcessResult: ...  # ✅
```

### 15.2 Docstrings
```python
async def create_meal(command: CreateMealCommand) -> Result[Meal, ValidationError]:
    """
    Create a new meal entry.
    
    Args:
        command: Command containing meal data
        
    Returns:
        Ok(Meal) if successful, Err(ValidationError) otherwise
        
    Raises:
        Never raises - errors are returned as Err
    """
```

### 15.3 Testing
```python
import pytest
from unittest.mock import AsyncMock

@pytest.mark.asyncio
async def test_meal_service_create():
    # Arrange
    mock_repo = AsyncMock(spec=MealRepository)
    service = MealService(mock_repo)
    command = CreateMealCommand(name="Test", calories=500)
    
    # Act
    result = await service.create_meal(command)
    
    # Assert
    assert isinstance(result, Ok)
    mock_repo.save.assert_called_once()
```

## 16. CHECKLIST PRE-COMMIT 📋

Prima di ogni commit, verifica:

- [ ] `mypy .` → zero errori type checking
- [ ] `black .` → codice formattato
- [ ] `flake8 .` → zero violazioni linting
- [ ] `./make.sh test` → tutti i test passano
- [ ] No warning di memoria o resource leak
- [ ] Dependency injection usata correttamente
- [ ] Nessun blocking I/O in funzioni async
- [ ] Context manager per resources
- [ ] Type hints completi

## 17. REFACTORING GUIDELINE 🔄

Quando refactori codice esistente:

1. **Identifica layer**: Questo è API, Domain o Infrastructure?
2. **Estrai business logic**: Sposta in service nel domain
3. **Crea repository**: Per ogni accesso dati
4. **Dependency injection**: Rimuovi import diretti
5. **Type safety**: Aggiungi type hints completi
6. **Test**: Scrivi test per la nuova struttura
7. **Cleanup**: Rimuovi codice vecchio

## 18. COMANDI QUALITÀ ESTESI

```bash
# Type check strict
mypy --strict --show-error-codes .

# Format check (non modifica)
black --check .

# Lint completo
flake8 . --statistics

# Test con coverage
pytest --cov=app --cov-report=term-missing

# Check import circolari
python -m pytest --import-mode=importlib
```

## 19. RISORSE E REFERENCE 📚

**Pattern consigliati:**
- Dependency Injection (FastAPI native)
- Repository Pattern
- Service Layer
- Domain-Driven Design (light)
- Result Type per error handling

**Librerie raccomandate:**
- `pydantic` → Validazione robusta
- `sqlalchemy` (async) → ORM type-safe
- `httpx` → HTTP client async
- `cachetools` → Cache con TTL
- `structlog` → Logging strutturato

**Da evitare:**
- `requests` → usa httpx async
- Global mutable state
- Sync code in async context
- God objects
- Codice procedurale

---

## RIEPILOGO PRINCIPI CHIAVE 🎯

1. **Layered Architecture** → API | Domain | Infrastructure
2. **Type Safety First** → mypy strict sempre
3. **Dependency Injection** → FastAPI Depends
4. **Async Native** → No blocking I/O
5. **Resource Management** → Context managers
6. **Memory Awareness** → Limits, pools, TTL
7. **Testability** → Mocking, dependency injection
8. **Clean Code** → Services, repositories, dataclasses

---

**Questo documento integra le istruzioni originali con best practices che risolvono i problemi di codice farraginoso, procedurale, memory leak e alto costo di manutenzione. Seguendo queste linee guida, il codice sarà più maintainable, type-safe e performante.**make documentation backend/docs/refactor-domain-meal-analysis.md backend/docs/nutrition-domain-completed.md backend/docs/meal-domain-plan.md