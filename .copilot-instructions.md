# Copilot Instructions - Extended Version

## 1. ARCHITETTURA PROGETTO
* Backend: backend/ â†’ **focus principale**.
* Altre cartelle: mobile/, web/ â†’ **non modificare salvo richiesta esplicita**.
* Tutte le operazioni di default devono riguardare **solo il backend**.

## 2. GESTIONE OPERAZIONI
* Usa **sempre** ./make.sh per:
  * Test
  * Versionamento
  * Build & deployment
  * Avvio Docker
* Prima di eseguire qualsiasi operazione, verifica i target disponibili:
```bash
cat ./make.sh
```

## 3. AMBIENTE PYTHON
* Attiva **sempre** il virtual environment backend/.venv:
```bash
source backend/.venv/bin/activate
```
* Usa **solo** il package manager uv per tutte le operazioni Python:
```bash
uv install
uv run
uv add <package>
```
* **Non usare** pip, poetry o altri strumenti.

## 4. TERMINALI
* Limite massimo: **3 terminali**
  1. BUILD â†’ sviluppo e build
  2. TEST â†’ esecuzione test
  3. GIT â†’ operazioni git
* **Non aprire terminali aggiuntivi.**

## 5. NAVIGAZIONE E ORIENTAMENTO
* Esegui sempre pwd prima di qualsiasi comando.
* Verifica la directory corrente e usa cd se necessario.

## 6. GESTIONE GIT
* Prima di ogni commit:
  1. Esegui git status
  2. Controlla staging e working directory
  3. Assicurati che non ci siano file indesiderati
* Solo dopo questi controlli procedi con il commit.

## 7. SEQUENZA OPERATIVA STANDARD
1. Orientamento: pwd
2. Ambiente: attiva virtual env
3. Status check: git status
4. Operazione: ./make.sh [target]
5. Verifica: controlla risultati

## 8. COMANDI PRINCIPALI
```bash
# Orientamento
pwd

# Ambiente Python
source backend/.venv/bin/activate

# Operazioni principali
./make.sh [target]

# Package management
uv [comando]

# Controllo versioning
git status
```

## 9. FOCUS E PRIORITÃ€
**Concentrati su:**
* Backend development
* Uso di make.sh per tutte le operazioni
* Gestione corretta del virtual environment
* Controlli git accurati

**Evita:**
* Apertura terminali extra
* Comandi Python senza virtual env
* Operazioni dirette senza make.sh
* Lavoro su mobile/web non richiesto

## 10. DOCUMENTAZIONE
* La documentazione principale parte dal file README.md nella root.
* Tutta la documentazione aggiuntiva si trova nella cartella docs/.
* Leggere **tutta la documentazione** in caso di dubbi o incertezze.

---

# ðŸš¨ NUOVE SEZIONI - ARCHITETTURA E BEST PRACTICES

## 11. ARCHITETTURA LAYERED - STRUTTURA OBBLIGATORIA

### 11.1 Struttura Directory Target
```
backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ api/              # Layer API/Presentazione
â”‚   â”‚   â”œâ”€â”€ graphql/      # Schema GraphQL e resolver Strawberry
â”‚   â”‚   â”œâ”€â”€ rest/         # Endpoint REST (se necessari)
â”‚   â”‚   â””â”€â”€ middleware/   # Middleware FastAPI
â”‚   â”œâ”€â”€ domain/           # Layer Business Logic (PURO)
â”‚   â”‚   â”œâ”€â”€ models/       # Domain models (dataclass, NOT ORM)
â”‚   â”‚   â”œâ”€â”€ services/     # Business logic services
â”‚   â”‚   â””â”€â”€ exceptions/   # Domain-specific exceptions
â”‚   â”œâ”€â”€ infrastructure/   # Layer Infrastruttura
â”‚   â”‚   â”œâ”€â”€ database/     # Repository, ORM, queries
â”‚   â”‚   â”œâ”€â”€ external/     # API esterne, HTTP clients
â”‚   â”‚   â”œâ”€â”€ cache/        # Redis, in-memory cache
â”‚   â”‚   â””â”€â”€ config/       # Configurazioni
â”‚   â””â”€â”€ core/             # Shared/Common
â”‚       â”œâ”€â”€ dependencies/ # Dependency Injection
â”‚       â”œâ”€â”€ utils/        # Utilities pure
â”‚       â””â”€â”€ types/        # Type definitions comuni
```

### 11.2 Principi di Separazione
* **API layer** â†’ Solo input/output, validazione request, chiamate a services
* **Domain layer** â†’ Business logic PURA, no I/O, no HTTP, no DB
* **Infrastructure layer** â†’ I/O, database, API esterne, filesystem

**REGOLA D'ORO**: Domain NON deve mai importare da API o Infrastructure

## 12. ANTIPATTERN DA EVITARE ðŸš«

### 12.1 Async/Await
âŒ **EVITARE:**
```python
# Blocking I/O in async function
async def get_user(user_id: int):
    time.sleep(1)  # MALE! Blocca event loop
    return db.query(User).filter_by(id=user_id).first()  # Sync in async
```

âœ… **CORRETTO:**
```python
async def get_user(user_id: int):
    await asyncio.sleep(1)  # Non-blocking
    return await db_async.execute(select(User).where(User.id == user_id))
```

### 12.2 Memory Leaks
âŒ **EVITARE:**
```python
# Global state mutabile
CACHE = {}  # Cresce infinitamente

async def store_data(key: str, value: Any):
    CACHE[key] = value  # Memory leak!
```

âœ… **CORRETTO:**
```python
from functools import lru_cache
from cachetools import TTLCache

# Cache con dimensione e TTL
cache: TTLCache = TTLCache(maxsize=1000, ttl=3600)

async def store_data(key: str, value: Any):
    cache[key] = value  # Auto-eviction
```

### 12.3 Resource Management
âŒ **EVITARE:**
```python
# Client HTTP non chiuso
async def fetch_data():
    client = httpx.AsyncClient()
    response = await client.get("https://api.example.com")
    return response.json()  # client non chiuso!
```

âœ… **CORRETTO:**
```python
async def fetch_data():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com")
        return response.json()  # Auto-cleanup
```

### 12.4 Codice Procedurale
âŒ **EVITARE:**
```python
# Tutto in un file, logica duplicata
async def create_meal(data: dict):
    # Validazione inline
    if not data.get("name"):
        raise ValueError("Name required")
    # Business logic inline
    calories = sum(i["calories"] for i in data["ingredients"])
    # Persistenza inline
    db.execute("INSERT INTO meals ...")
    # Notifiche inline
    await send_email(...)
```

âœ… **CORRETTO:**
```python
# Domain service
class MealService:
    def __init__(self, repo: MealRepository, notifier: Notifier):
        self._repo = repo
        self._notifier = notifier
    
    async def create_meal(self, command: CreateMealCommand) -> Meal:
        meal = Meal.create(command)  # Factory domain
        meal.calculate_nutrition()   # Business logic
        await self._repo.save(meal)
        await self._notifier.notify_meal_created(meal)
        return meal
```

## 13. PATTERN E LIBRERIE DA PREDILIGERE âœ…

### 13.1 Dependency Injection
**Usa SEMPRE dependency injection di FastAPI:**
```python
from fastapi import Depends
from typing import Annotated

# Dependencies file
def get_db_session() -> AsyncSession:
    async with async_session_maker() as session:
        yield session

def get_meal_service(
    db: Annotated[AsyncSession, Depends(get_db_session)]
) -> MealService:
    repo = MealRepository(db)
    return MealService(repo)

# In resolver Strawberry
@strawberry.type
class Query:
    @strawberry.field
    async def meal(
        self,
        info: Info,
        meal_id: int,
        service: Annotated[MealService, Depends(get_meal_service)]
    ) -> Meal:
        return await service.get_meal(meal_id)
```

### 13.2 Dataclasses & Type Safety
**Usa dataclasses e pydantic per domain models:**
```python
from dataclasses import dataclass, field
from typing import NewType

UserId = NewType("UserId", int)
MealId = NewType("MealId", int)

@dataclass(frozen=True)  # Immutabile
class Meal:
    id: MealId
    user_id: UserId
    name: str
    calories: int
    created_at: datetime = field(default_factory=datetime.utcnow)
    
    def __post_init__(self):
        if self.calories < 0:
            raise ValueError("Calories cannot be negative")
```

### 13.3 Repository Pattern
**SEMPRE usa repository per accesso dati:**
```python
from abc import ABC, abstractmethod
from typing import Protocol

class MealRepository(Protocol):
    async def get_by_id(self, meal_id: MealId) -> Meal | None: ...
    async def save(self, meal: Meal) -> None: ...
    async def find_by_user(self, user_id: UserId) -> list[Meal]: ...

# Implementation
class PostgresMealRepository:
    def __init__(self, session: AsyncSession):
        self._session = session
    
    async def get_by_id(self, meal_id: MealId) -> Meal | None:
        result = await self._session.execute(
            select(MealModel).where(MealModel.id == meal_id)
        )
        model = result.scalar_one_or_none()
        return self._to_domain(model) if model else None
```

### 13.4 Result Type invece di Eccezioni
**Per flow control, usa Result type:**
```python
from typing import Generic, TypeVar
from dataclasses import dataclass

T = TypeVar("T")
E = TypeVar("E")

@dataclass(frozen=True)
class Ok(Generic[T]):
    value: T

@dataclass(frozen=True)
class Err(Generic[E]):
    error: E

Result = Ok[T] | Err[E]

# Uso
async def create_meal(command: CreateMealCommand) -> Result[Meal, str]:
    if not command.name:
        return Err("Name is required")
    
    meal = Meal.create(command)
    await repo.save(meal)
    return Ok(meal)
```

### 13.5 Context Manager per Resources
**SEMPRE usa context manager per cleanup:**
```python
from contextlib import asynccontextmanager
from typing import AsyncIterator

@asynccontextmanager
async def get_api_client() -> AsyncIterator[httpx.AsyncClient]:
    client = httpx.AsyncClient(timeout=30.0)
    try:
        yield client
    finally:
        await client.aclose()

# Uso
async def fetch_nutrition_data():
    async with get_api_client() as client:
        response = await client.get("...")
        return response.json()
```

## 14. GESTIONE MEMORIA E PERFORMANCE ðŸš€

### 14.1 Limitazioni Concorrenza
```python
import asyncio
from asyncio import Semaphore

# Limita chiamate concorrenti
semaphore = Semaphore(10)

async def process_meal(meal_id: int):
    async with semaphore:
        # Max 10 concurrent
        await heavy_processing(meal_id)
```

### 14.2 Streaming per Dati Grandi
```python
# NO - carica tutto in memoria
async def get_all_meals():
    return await db.execute(select(Meal)).all()

# YES - stream results
async def stream_meals() -> AsyncIterator[Meal]:
    async for row in db.stream(select(Meal)):
        yield row
```

### 14.3 Connection Pooling
```python
from sqlalchemy.ext.asyncio import create_async_engine

# Pool configurato correttamente
engine = create_async_engine(
    DATABASE_URL,
    pool_size=10,          # Connessioni persistenti
    max_overflow=20,       # Extra temporanee
    pool_pre_ping=True,    # Verifica health
    pool_recycle=3600,     # Ricicla dopo 1h
)
```

## 15. STANDARD CODICE E QUALITY ðŸ“

### 15.1 Type Hints OBBLIGATORI
```python
# SEMPRE annota tipi
async def calculate_nutrition(
    meals: list[Meal],
    user_weight: float,
) -> NutritionSummary:
    ...

# NO generics nudi
def process(data): ...  # âŒ

# YES
def process(data: list[dict[str, Any]]) -> ProcessResult: ...  # âœ…
```

### 15.2 Docstrings
```python
async def create_meal(command: CreateMealCommand) -> Result[Meal, ValidationError]:
    """
    Create a new meal entry.
    
    Args:
        command: Command containing meal data
        
    Returns:
        Ok(Meal) if successful, Err(ValidationError) otherwise
        
    Raises:
        Never raises - errors are returned as Err
    """
```

### 15.3 Testing
```python
import pytest
from unittest.mock import AsyncMock

@pytest.mark.asyncio
async def test_meal_service_create():
    # Arrange
    mock_repo = AsyncMock(spec=MealRepository)
    service = MealService(mock_repo)
    command = CreateMealCommand(name="Test", calories=500)
    
    # Act
    result = await service.create_meal(command)
    
    # Assert
    assert isinstance(result, Ok)
    mock_repo.save.assert_called_once()
```

## 16. CHECKLIST PRE-COMMIT ðŸ“‹

Prima di ogni commit, verifica:

- [ ] `mypy .` â†’ zero errori type checking
- [ ] `black .` â†’ codice formattato
- [ ] `flake8 .` â†’ zero violazioni linting
- [ ] `./make.sh test` â†’ tutti i test passano
- [ ] No warning di memoria o resource leak
- [ ] Dependency injection usata correttamente
- [ ] Nessun blocking I/O in funzioni async
- [ ] Context manager per resources
- [ ] Type hints completi

## 17. REFACTORING GUIDELINE ðŸ”„

Quando refactori codice esistente:

1. **Identifica layer**: Questo Ã¨ API, Domain o Infrastructure?
2. **Estrai business logic**: Sposta in service nel domain
3. **Crea repository**: Per ogni accesso dati
4. **Dependency injection**: Rimuovi import diretti
5. **Type safety**: Aggiungi type hints completi
6. **Test**: Scrivi test per la nuova struttura
7. **Cleanup**: Rimuovi codice vecchio

## 18. COMANDI QUALITÃ€ ESTESI

```bash
# Type check strict
mypy --strict --show-error-codes .

# Format check (non modifica)
black --check .

# Lint completo
flake8 . --statistics

# Test con coverage
pytest --cov=app --cov-report=term-missing

# Check import circolari
python -m pytest --import-mode=importlib
```

## 19. RISORSE E REFERENCE ðŸ“š

**Pattern consigliati:**
- Dependency Injection (FastAPI native)
- Repository Pattern
- Service Layer
- Domain-Driven Design (light)
- Result Type per error handling

**Librerie raccomandate:**
- `pydantic` â†’ Validazione robusta
- `sqlalchemy` (async) â†’ ORM type-safe
- `httpx` â†’ HTTP client async
- `cachetools` â†’ Cache con TTL
- `structlog` â†’ Logging strutturato

**Da evitare:**
- `requests` â†’ usa httpx async
- Global mutable state
- Sync code in async context
- God objects
- Codice procedurale

---

## RIEPILOGO PRINCIPI CHIAVE ðŸŽ¯

1. **Layered Architecture** â†’ API | Domain | Infrastructure
2. **Type Safety First** â†’ mypy strict sempre
3. **Dependency Injection** â†’ FastAPI Depends
4. **Async Native** â†’ No blocking I/O
5. **Resource Management** â†’ Context managers
6. **Memory Awareness** â†’ Limits, pools, TTL
7. **Testability** â†’ Mocking, dependency injection
8. **Clean Code** â†’ Services, repositories, dataclasses

---

**Questo documento integra le istruzioni originali con best practices che risolvono i problemi di codice farraginoso, procedurale, memory leak e alto costo di manutenzione. Seguendo queste linee guida, il codice sarÃ  piÃ¹ maintainable, type-safe e performante.**make documentation backend/docs/refactor-domain-meal-analysis.md backend/docs/nutrition-domain-completed.md backend/docs/meal-domain-plan.md