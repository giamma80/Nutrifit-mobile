# Copilot Instructions - Extended Version

## My Environment
- macOS M1
- Python 3.11 (virtualenv in backend/.venv)
- zsh shell


## My practices
- I use uv for package management
- I use Git for version control
- I use Docker for containerization
- I use colima for Docker on macOS M1
- I use make.sh for build, test, deployment, and Docker management (located in backend/make.sh)
    - Example targets:
      - run-bg
      - stop
      - docker-build
      - docker-up
      - docker-down
      - test
      - build
      - release
    - typical flow:
      1. Check available targets: `make help` or `cat ./make.sh`
      2. Run target: `./make.sh [target]`
        a. E.g., `./make.sh format` to format the code
        b. E.g., `./make.sh lint` to run linters
        c. E.g., `./make.sh test` to run tests
        d. E.g., `./make.sh schema-check` to check GraphQL schema
        e. E.g., `./make.sh schema-export` to export GraphQL schema
        f. E.g., `./make.sh build` to build the project
        g. E.g., `./make.sh docker-up` to start Docker services
        h. E.g., `./make.sh docker-down` to stop Docker services
        i. E.g., `./make.sh docker-restart` to restart backend service
        j. E.g., `./make.sh release` to create a new release

- I always activate the virtual environment before running Python commands:
```bash
source backend/.venv/bin/activate
```
- I have a limit of 3 terminal windows:
  1. BUILD
  2. TEST
  3. GIT  
- I always check my current directory with `pwd` before running commands
- I always run `git status` before committing to check for unwanted files
- I never open additional terminal windows beyond the limit
- I never run Python commands outside the virtual environment
- I always use uv for package management, never pip or poetry
- I always use uv for running scripts, never python directly


## Programming skills
- Proficient in Python, JavaScript, TypeScript
- Experienced with FastAPI, Strawberry GraphQL, SQLAlchemy
- Familiar with Docker, Git, CI/CD pipelines
- Knowledgeable in RESTful API design, async programming, and database management
- Strong understanding of software architecture and design patterns
- Experienced in writing unit and integration tests
- AI/ML knowledge for integrating AI models into applications
- prompt engineering skills for AI model interactions
- MCP certified developer

## Communication style
- Clear and concise
- Professional and respectful
- Detail-oriented
- Focused on problem-solving
- check documentation before asking questions
- find answers online before asking for help

## Domain knowledge
- Web development
- Nutrition and health applications
- AI integration in software solutions

## QA best practices
- Implement automated testing for all new features
- Conduct regular code reviews and pair programming sessions
- Maintain comprehensive documentation for all APIs and services
- Use static analysis tools to catch potential issues early
- Encourage a culture of quality and accountability within the team
- Test Driven Development (TDD) approach for new features and bug fixes

# Issue Management
- Report issues with clear reproduction steps
- Follow up on reported issues to ensure resolution
- Do not ignore any reported issues
- Focus on resolving issues promptly and effectively
- Diligent tracking of issues until closure

## Before Starting Any Task
1. Ask clarifying questions
2. Explain your approach
3. Consider edge cases


## 1. ARCHITETTURA PROGETTO
* Backend: backend/ → **focus principale**.
* Altre cartelle: mobile/, web/ → **non modificare salvo richiesta esplicita**.
* Tutte le operazioni di default devono riguardare **solo il backend**.

## 2. GESTIONE OPERAZIONI
* Usa **sempre** ./make.sh per:
  * Test
  * Versionamento
  * Build & deployment
  * Avvio Docker
* Prima di eseguire qualsiasi operazione, verifica i target disponibili:
```bash
cat ./make.sh
```

## 3. AMBIENTE PYTHON
* Attiva **sempre** il virtual environment backend/.venv:
```bash
source backend/.venv/bin/activate
```
* Usa **solo** il package manager uv per tutte le operazioni Python:
```bash
uv install
uv run
uv add <package>
```
* **Non usare** pip, poetry o altri strumenti.

## 4. TERMINALI
* Limite massimo: **3 terminali**
  1. BUILD → sviluppo e build
  2. TEST → esecuzione test
  3. GIT → operazioni git
* **Non aprire terminali aggiuntivi.**

## 5. NAVIGAZIONE E ORIENTAMENTO
* Esegui sempre pwd prima di qualsiasi comando.
* Verifica la directory corrente e usa cd se necessario.

## 6. GESTIONE GIT
* Prima di ogni commit:
  1. Esegui git status
  2. Controlla staging e working directory
  3. Assicurati che non ci siano file indesiderati
* Solo dopo questi controlli procedi con il commit.

## 7. SEQUENZA OPERATIVA STANDARD
1. Orientamento: pwd
2. Ambiente: attiva virtual env
3. Status check: git status
4. Operazione: ./make.sh [target]
5. Verifica: controlla risultati

## 8. COMANDI PRINCIPALI
```bash
# Orientamento
pwd

# Ambiente Python
source backend/.venv/bin/activate

# Operazioni principali
./make.sh [target]

# Package management
uv [comando]

# Controllo versioning
git status
```

## 9. FOCUS E PRIORITÀ
**Concentrati su:**
* Backend development
* Uso di make.sh per tutte le operazioni
* Gestione corretta del virtual environment
* Controlli git accurati

**Evita:**
* Apertura terminali extra
* Comandi Python senza virtual env
* Operazioni dirette senza make.sh
* Lavoro su mobile/web non richiesto



---

# 🚨 NUOVE SEZIONI - ARCHITETTURA E BEST PRACTICES

## 11. ARCHITETTURA LAYERED - STRUTTURA OBBLIGATORIA

### 11.1 Struttura Directory Target
```
backend/
├── app/
│   ├── api/              # Layer API/Presentazione
│   │   ├── graphql/      # Schema GraphQL e resolver Strawberry
│   │   ├── rest/         # Endpoint REST (se necessari)
│   │   └── middleware/   # Middleware FastAPI
│   ├── domain/           # Layer Business Logic (PURO)
│   │   ├── models/       # Domain models (dataclass, NOT ORM)
│   │   ├── services/     # Business logic services
│   │   └── exceptions/   # Domain-specific exceptions
│   ├── infrastructure/   # Layer Infrastruttura
│   │   ├── database/     # Repository, ORM, queries
│   │   ├── external/     # API esterne, HTTP clients
│   │   ├── cache/        # Redis, in-memory cache
│   │   └── config/       # Configurazioni
│   └── core/             # Shared/Common
│       ├── dependencies/ # Dependency Injection
│       ├── utils/        # Utilities pure
│       └── types/        # Type definitions comuni
```

### 11.2 Principi di Separazione
* **API layer** → Solo input/output, validazione request, chiamate a services
* **Domain layer** → Business logic PURA, no I/O, no HTTP, no DB
* **Infrastructure layer** → I/O, database, API esterne, filesystem

**REGOLA D'ORO**: Domain NON deve mai importare da API o Infrastructure

## 12. ANTIPATTERN DA EVITARE 🚫

### 12.1 Async/Await
❌ **EVITARE:**
```python
# Blocking I/O in async function
async def get_user(user_id: int):
    time.sleep(1)  # MALE! Blocca event loop
    return db.query(User).filter_by(id=user_id).first()  # Sync in async
```

✅ **CORRETTO:**
```python
async def get_user(user_id: int):
    await asyncio.sleep(1)  # Non-blocking
    return await db_async.execute(select(User).where(User.id == user_id))
```

### 12.2 Memory Leaks
❌ **EVITARE:**
```python
# Global state mutabile
CACHE = {}  # Cresce infinitamente

async def store_data(key: str, value: Any):
    CACHE[key] = value  # Memory leak!
```

✅ **CORRETTO:**
```python
from functools import lru_cache
from cachetools import TTLCache

# Cache con dimensione e TTL
cache: TTLCache = TTLCache(maxsize=1000, ttl=3600)

async def store_data(key: str, value: Any):
    cache[key] = value  # Auto-eviction
```

### 12.3 Resource Management
❌ **EVITARE:**
```python
# Client HTTP non chiuso
async def fetch_data():
    client = httpx.AsyncClient()
    response = await client.get("https://api.example.com")
    return response.json()  # client non chiuso!
```

✅ **CORRETTO:**
```python
async def fetch_data():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com")
        return response.json()  # Auto-cleanup
```

### 12.4 Codice Procedurale
❌ **EVITARE:**
```python
# Tutto in un file, logica duplicata
async def create_meal(data: dict):
    # Validazione inline
    if not data.get("name"):
        raise ValueError("Name required")
    # Business logic inline
    calories = sum(i["calories"] for i in data["ingredients"])
    # Persistenza inline
    db.execute("INSERT INTO meals ...")
    # Notifiche inline
    await send_email(...)
```

✅ **CORRETTO:**
```python
# Domain service
class MealService:
    def __init__(self, repo: MealRepository, notifier: Notifier):
        self._repo = repo
        self._notifier = notifier
    
    async def create_meal(self, command: CreateMealCommand) -> Meal:
        meal = Meal.create(command)  # Factory domain
        meal.calculate_nutrition()   # Business logic
        await self._repo.save(meal)
        await self._notifier.notify_meal_created(meal)
        return meal
```

## 13. PATTERN E LIBRERIE DA PREDILIGERE ✅

### 13.1 Dependency Injection
**Usa SEMPRE dependency injection di FastAPI:**
```python
from fastapi import Depends
from typing import Annotated

# Dependencies file
def get_db_session() -> AsyncSession:
    async with async_session_maker() as session:
        yield session

def get_meal_service(
    db: Annotated[AsyncSession, Depends(get_db_session)]
) -> MealService:
    repo = MealRepository(db)
    return MealService(repo)

# In resolver Strawberry
@strawberry.type
class Query:
    @strawberry.field
    async def meal(
        self,
        info: Info,
        meal_id: int,
        service: Annotated[MealService, Depends(get_meal_service)]
    ) -> Meal:
        return await service.get_meal(meal_id)
```

### 13.2 Dataclasses & Type Safety
**Usa dataclasses e pydantic per domain models:**
```python
from dataclasses import dataclass, field
from typing import NewType

UserId = NewType("UserId", int)
MealId = NewType("MealId", int)

@dataclass(frozen=True)  # Immutabile
class Meal:
    id: MealId
    user_id: UserId
    name: str
    calories: int
    created_at: datetime = field(default_factory=datetime.utcnow)
    
    def __post_init__(self):
        if self.calories < 0:
            raise ValueError("Calories cannot be negative")
```

### 13.3 Repository Pattern
**SEMPRE usa repository per accesso dati:**
```python
from abc import ABC, abstractmethod
from typing import Protocol

class MealRepository(Protocol):
    async def get_by_id(self, meal_id: MealId) -> Meal | None: ...
    async def save(self, meal: Meal) -> None: ...
    async def find_by_user(self, user_id: UserId) -> list[Meal]: ...

# Implementation
class PostgresMealRepository:
    def __init__(self, session: AsyncSession):
        self._session = session
    
    async def get_by_id(self, meal_id: MealId) -> Meal | None:
        result = await self._session.execute(
            select(MealModel).where(MealModel.id == meal_id)
        )
        model = result.scalar_one_or_none()
        return self._to_domain(model) if model else None
```

### 13.4 Result Type invece di Eccezioni
**Per flow control, usa Result type:**
```python
from typing import Generic, TypeVar
from dataclasses import dataclass

T = TypeVar("T")
E = TypeVar("E")

@dataclass(frozen=True)
class Ok(Generic[T]):
    value: T

@dataclass(frozen=True)
class Err(Generic[E]):
    error: E

Result = Ok[T] | Err[E]

# Uso
async def create_meal(command: CreateMealCommand) -> Result[Meal, str]:
    if not command.name:
        return Err("Name is required")
    
    meal = Meal.create(command)
    await repo.save(meal)
    return Ok(meal)
```

### 13.5 Context Manager per Resources
**SEMPRE usa context manager per cleanup:**
```python
from contextlib import asynccontextmanager
from typing import AsyncIterator

@asynccontextmanager
async def get_api_client() -> AsyncIterator[httpx.AsyncClient]:
    client = httpx.AsyncClient(timeout=30.0)
    try:
        yield client
    finally:
        await client.aclose()

# Uso
async def fetch_nutrition_data():
    async with get_api_client() as client:
        response = await client.get("...")
        return response.json()
```

## 14. GESTIONE MEMORIA E PERFORMANCE 🚀

### 14.1 Limitazioni Concorrenza
```python
import asyncio
from asyncio import Semaphore

# Limita chiamate concorrenti
semaphore = Semaphore(10)

async def process_meal(meal_id: int):
    async with semaphore:
        # Max 10 concurrent
        await heavy_processing(meal_id)
```

### 14.2 Streaming per Dati Grandi
```python
# NO - carica tutto in memoria
async def get_all_meals():
    return await db.execute(select(Meal)).all()

# YES - stream results
async def stream_meals() -> AsyncIterator[Meal]:
    async for row in db.stream(select(Meal)):
        yield row
```

### 14.3 Connection Pooling
```python
from sqlalchemy.ext.asyncio import create_async_engine

# Pool configurato correttamente
engine = create_async_engine(
    DATABASE_URL,
    pool_size=10,          # Connessioni persistenti
    max_overflow=20,       # Extra temporanee
    pool_pre_ping=True,    # Verifica health
    pool_recycle=3600,     # Ricicla dopo 1h
)
```

## 15. STANDARD CODICE E QUALITY 📐

### 15.1 Type Hints OBBLIGATORI
```python
# SEMPRE annota tipi
async def calculate_nutrition(
    meals: list[Meal],
    user_weight: float,
) -> NutritionSummary:
    ...

# NO generics nudi
def process(data): ...  # ❌

# YES
def process(data: list[dict[str, Any]]) -> ProcessResult: ...  # ✅
```

### 15.2 Docstrings
```python
async def create_meal(command: CreateMealCommand) -> Result[Meal, ValidationError]:
    """
    Create a new meal entry.
    
    Args:
        command: Command containing meal data
        
    Returns:
        Ok(Meal) if successful, Err(ValidationError) otherwise
        
    Raises:
        Never raises - errors are returned as Err
    """
```

### 15.3 Testing
```python
import pytest
from unittest.mock import AsyncMock

@pytest.mark.asyncio
async def test_meal_service_create():
    # Arrange
    mock_repo = AsyncMock(spec=MealRepository)
    service = MealService(mock_repo)
    command = CreateMealCommand(name="Test", calories=500)
    
    # Act
    result = await service.create_meal(command)
    
    # Assert
    assert isinstance(result, Ok)
    mock_repo.save.assert_called_once()
```

## 16. CHECKLIST PRE-COMMIT 📋

Prima di ogni commit, verifica:

- [ ] `mypy .` → zero errori type checking
- [ ] `black .` → codice formattato
- [ ] `flake8 .` → zero violazioni linting
- [ ] `./make.sh test` → tutti i test passano
- [ ] No warning di memoria o resource leak
- [ ] Dependency injection usata correttamente
- [ ] Nessun blocking I/O in funzioni async
- [ ] Context manager per resources
- [ ] Type hints completi

## 17. REFACTORING GUIDELINE 🔄

Quando refactori codice esistente:

1. **Identifica layer**: Questo è API, Domain o Infrastructure?
2. **Estrai business logic**: Sposta in service nel domain
3. **Crea repository**: Per ogni accesso dati
4. **Dependency injection**: Rimuovi import diretti
5. **Type safety**: Aggiungi type hints completi
6. **Test**: Scrivi test per la nuova struttura
7. **Cleanup**: Rimuovi codice vecchio

## 18. COMANDI QUALITÀ ESTESI

```bash
# Type check strict
mypy --strict --show-error-codes .

# Format check (non modifica)
black --check .

# Lint completo
flake8 . --statistics

# Test con coverage
pytest --cov=app --cov-report=term-missing

# Check import circolari
python -m pytest --import-mode=importlib
```

## 19. RISORSE E REFERENCE 📚

**Pattern consigliati:**
- Dependency Injection (FastAPI native)
- Repository Pattern
- Service Layer
- Domain-Driven Design (light)
- Result Type per error handling

**Librerie raccomandate:**
- `pydantic` → Validazione robusta
- `sqlalchemy` (async) → ORM type-safe
- `httpx` → HTTP client async
- `cachetools` → Cache con TTL
- `structlog` → Logging strutturato

**Da evitare:**
- `requests` → usa httpx async
- Global mutable state
- Sync code in async context
- God objects
- Codice procedurale

---

## RIEPILOGO PRINCIPI CHIAVE 🎯

1. **Layered Architecture** → API | Domain | Infrastructure
2. **Type Safety First** → mypy strict sempre
3. **Dependency Injection** → FastAPI Depends
4. **Async Native** → No blocking I/O
5. **Resource Management** → Context managers
6. **Memory Awareness** → Limits, pools, TTL
7. **Testability** → Mocking, dependency injection
8. **Clean Code** → Services, repositories, dataclasses

---

**Questo documento integra le istruzioni originali con best practices che risolvono i problemi di codice farraginoso, procedurale, memory leak e alto costo di manutenzione. Seguendo queste linee guida, il codice sarà più maintainable, type-safe e performante.**

---

# 🚨 SEZIONE 20: REFACTORING MEAL DOMAIN - REGOLE FERREE

## 20.1 DOCUMENTAZIONE DI RIFERIMENTO OBBLIGATORIA

**Location:** `backend/REFACTOR/`

Questa cartella contiene la **documentazione completa e autoritativa** per il refactor del dominio Meal. **NESSUNA deviazione è permessa** fino al completamento del processo.

### 📚 Documenti Core (LEGGI IN ORDINE)

1. **README.md** - Overview e quick start
2. **IMPLEMENTATION_TRACKER.md** - ⭐ **DOCUMENTO PRINCIPALE DI TRACKING**
3. **00_ARCHITECTURE_OVERVIEW.md** - Vision e principi architetturali
4. **01_IMPLEMENTATION_GUIDE.md** - Guida implementazione 7 fasi
5. **02_DOMAIN_LAYER.md** - Specifiche domain layer
6. **03_APPLICATION_LAYER.md** - Specifiche application layer (CQRS)
7. **04_INFRASTRUCTURE_LAYER.md** - Specifiche infrastructure layer
8. **05_TESTING_STRATEGY.md** - Strategia TDD e testing
9. **06_GRAPHQL_API.md** - Schema GraphQL completo

---

## 20.2 REGOLE FERREE - NON NEGOZIABILI ⚠️

### REGOLA #1: IMPLEMENTATION TRACKER È LA FONTE DI VERITÀ
```markdown
**PRIMA DI QUALSIASI MODIFICA AL CODICE:**
1. Apri backend/REFACTOR/IMPLEMENTATION_TRACKER.md
2. Identifica il task corrente (es: P0.1, P1.2, etc.)
3. Leggi TUTTI i subtask associati
4. Segui ESATTAMENTE i riferimenti alla documentazione
5. Completa task secondo criteri definiti
6. Aggiorna status nel tracker
7. SOLO DOPO procedi al task successivo
```

### REGOLA #2: SEQUENZA OBBLIGATORIA - NO SKIP
```
Phase 0 → Phase 1 → Phase 2 → Phase 3 → Phase 4 → Phase 5 → Phase 6 → Phase 7

NON SI PUÒ:
❌ Saltare task o phase
❌ Fare task in ordine diverso
❌ Lavorare su più phase in parallelo (eccetto testing)
❌ Improvvisare soluzioni non documentate
```

### REGOLA #3: ORTODOSSIA DOCUMENTALE
```
Se la documentazione dice:
✅ "Implementare X in modo Y" → Fai ESATTAMENTE quello
✅ "Adattare client Z preservando logica" → Preserva TUTTA la logica esistente
✅ "Testare con coverage >90%" → Coverage DEVE essere >90%

NON ACCETTABILE:
❌ "Ho fatto in modo simile ma diverso"
❌ "Ho saltato test perché sembravano ridondanti"
❌ "Ho riscritto da zero invece di adattare"
```

### REGOLA #4: OGNI TASK HA CRITERI DI COMPLETAMENTO
```markdown
Un task è COMPLETED solo quando:
✅ Codice implementato secondo spec
✅ Test scritti e passano (coverage target)
✅ Documentazione aggiornata (docstrings)
✅ Commit con conventional commit message
✅ Status aggiornato in IMPLEMENTATION_TRACKER.md
```

### REGOLA #5: PRESERVAZIONE CLIENT ESTERNI
```
QUESTI FILE SONO SACRI - DA ADATTARE, NON CANCELLARE:
✅ backend/ai_models/usda_client.py
✅ backend/openfoodfacts/adapter.py
✅ backend/ai_models/meal_photo_prompt.py
✅ backend/ai_models/nutrient_enrichment.py

APPROACH: Spostare in infrastructure/, implementare ports, aggiungere circuit breaker.
NON riscrivere da zero.
```

---

## 20.3 WORKFLOW OPERATIVO STANDARD

### Per Ogni Task (Loop Obbligatorio)

```bash
# 1. CONSULTA TRACKER
cat backend/REFACTOR/IMPLEMENTATION_TRACKER.md | grep "P[0-7]\.[0-9]"

# 2. LEGGI TASK DETTAGLI
# Identifica ID (es: P1.3.2)
# Leggi: Description, Reference Doc, Expected Result

# 3. CONSULTA DOCUMENTAZIONE DI RIFERIMENTO
# Es: Reference = "02_DOMAIN_LAYER.md §500-650"
cat backend/REFACTOR/02_DOMAIN_LAYER.md | sed -n '500,650p'

# 4. IMPLEMENTA SECONDO SPEC
# Segui ESATTAMENTE le specifiche
# NO improvvisazione

# 5. TESTA
./make.sh test
# Se coverage target specificato, verifica

# 6. AGGIORNA TRACKER
# Modifica status in IMPLEMENTATION_TRACKER.md:
# ⚪ NOT_STARTED → 🟢 COMPLETED

# 7. COMMIT
git add .
git commit -m "feat(domain): implement Meal aggregate [P1.3.2]

- Implemented Meal entity according to 02_DOMAIN_LAYER.md §500-650
- Added business methods: add_entry(), calculate_totals(), confirm()
- Tests coverage: 95%
- Closes task P1.3.2"

# 8. RIPETI per task successivo
```

---

## 20.4 PRIORITY TASK - CRITICAL PATH

**Questi task BLOCCANO tutto il resto:**

1. **P0.1** - Upgrade OpenAI 2.5.0+ (BLOCKING per structured outputs)
2. **P0.3** - Selective Cleanup (BLOCKING per nuova struttura)
3. **P1.x** - Core domain (BLOCKING per capabilities)
4. **P2.x** - Ports definition (BLOCKING per infrastructure)
5. **P3.1-3.3** - Client adapters (BLOCKING per application)

**Non procedere oltre se questi non sono completati.**

---

## 20.5 QUANDO CHIEDERE CHIARIMENTI

**CHIEDI SEMPRE SE:**
- ❓ La documentazione è ambigua su un punto specifico
- ❓ Trovi conflitto tra documenti diversi
- ❓ Un expected result non è chiaro
- ❓ Devi deviare dalla spec per motivo tecnico valido

**NON IMPROVVISARE MAI:**
- ❌ "Penso che volesse dire..."
- ❌ "Ho fatto a modo mio perché più efficiente"
- ❌ "Ho saltato perché non necessario"

---

## 20.6 MILESTONE VERIFICATION

**Dopo ogni Phase, verifica milestone:**

```bash
# Phase 1 Milestone Check
- ✅ Core domain implementato?
- ✅ Value objects, events, entities, exceptions, factories?
- ✅ Tests coverage >90%?
- ✅ Tutti i task P1.x COMPLETED in tracker?

# Se una sola ✅ manca → NON procedere a Phase 2
```

---

## 20.7 DOCUMENTAZIONE COME CODICE

```
La documentazione in backend/REFACTOR/ è:
✅ Specificazione formale (come RFC)
✅ Contratto di implementazione (come API contract)
✅ Fonte di verità unica (come schema database)

NON è:
❌ Suggerimento
❌ Linea guida opzionale
❌ Idea da interpretare liberamente
```

---

## 20.8 ESEMPIO TASK EXECUTION

```markdown
## ESEMPIO: Task P1.3.2 - Meal Aggregate

### 1. Leggi Task
ID: P1.3.2
Description: Meal aggregate
Reference: 02_DOMAIN_LAYER.md §500-650
Expected: Meal aggregate root con metodi business
Status: ⚪ NOT_STARTED

### 2. Consulta Doc
$ cat backend/REFACTOR/02_DOMAIN_LAYER.md | sed -n '500,650p'
[Leggi specifiche complete]

### 3. Implementa
$ cat > backend/domain/meal/core/entities/meal.py << 'EOF'
# Implementazione ESATTA secondo spec §500-650
...
EOF

### 4. Testa
$ ./make.sh test
Coverage: 95% ✅

### 5. Aggiorna Tracker
Status: ⚪ NOT_STARTED → 🟢 COMPLETED

### 6. Commit
$ git commit -m "feat(domain): implement Meal aggregate [P1.3.2]"

### 7. Next
Procedi a P1.3.3
```

---

## 20.9 ANTIPATTERN DA EVITARE NEL REFACTOR

### ❌ WRONG:
```python
# "Ho fatto a modo mio"
class Meal:  # Diverso da spec
    def save(self):  # Non nel domain!
        db.save(self)
```

### ✅ CORRECT:
```python
# Seguendo 02_DOMAIN_LAYER.md §500-650
@dataclass
class Meal:  # Esattamente come spec
    def add_entry(self, entry: MealEntry) -> None:
        # Business logic PURA
        self._entries.append(entry)
        self._recalculate_totals()
```

---

## 20.10 SUMMARY - GOLDEN RULES

```
1️⃣ IMPLEMENTATION_TRACKER.md è la checklist OBBLIGATORIA
2️⃣ Segui task in ORDINE SEQUENZIALE (no skip)
3️⃣ Ogni task ha REFERENCE DOC → leggilo SEMPRE
4️⃣ Expected Result è CRITERIO DI COMPLETAMENTO
5️⃣ Preserva CLIENT ESTERNI (USDA, OpenFoodFacts)
6️⃣ Coverage >90% è OBBLIGATORIO
7️⃣ Aggiorna STATUS dopo ogni task
8️⃣ Commit con [TASK_ID] nel messaggio
9️⃣ Verifica MILESTONE prima di next phase
🔟 In caso di dubbio → CHIEDI, non improvvisare
```

---

## 20.11 COMMIT MESSAGE CONVENTION PER REFACTOR

```bash
# Format obbligatorio
<type>(scope): <description> [TASK_ID]

# Examples:
feat(domain): add MealEntry entity [P1.3.1]
refactor(infrastructure): adapt USDA client to INutritionProvider [P3.2.2]
test(application): add PhotoAnalysisCommand tests [P4.1.7]
docs(refactor): update tracker status for Phase 1 [P1.x]

# Scope validi per refactor:
- domain
- application
- infrastructure
- graphql
- tests
- refactor (per meta-operazioni)
```

---

## 🎯 DICHIARAZIONE FINALE

**Fino al completamento del refactor (tutti i task P0-P7 COMPLETED):**

✅ **DEVI:** Seguire IMPLEMENTATION_TRACKER.md ortodossamente  
✅ **DEVI:** Consultare documenti di riferimento per ogni task  
✅ **DEVI:** Rispettare expected results e criteri di completamento  
✅ **DEVI:** Preservare logica client esterni (adapt, non rewrite)  
✅ **DEVI:** Mantenere coverage >90%  
✅ **DEVI:** Aggiornare status tracker dopo ogni task  

❌ **NON PUOI:** Saltare task o modificare sequenza  
❌ **NON PUOI:** Improvvisare soluzioni non documentate  
❌ **NON PUOI:** Riscrivere da zero codice da preservare  
❌ **NON PUOI:** Ignorare specifiche tecniche nei documenti  
❌ **NON PUOI:** Procedere senza verificare milestone  

---

**Il refactor è un processo ingegneristico formale, non creativo. La documentazione è legge fino al deployment in produzione (Phase 7 completa).**